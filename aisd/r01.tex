\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{silence}
\usepackage{polski}
\usepackage{parskip}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{enumitem}
%\usepackage{pgfplots}
%\pgfplotsset{compat=1.16}
\usepackage{newunicodechar}
\usepackage{etoolbox}
\usepackage[margin=1.2in]{geometry}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\setcounter{secnumdepth}{0}

\title{AISD lista 1}
\author{Wiktor Kuchta}
\date{\vspace{-4ex}}

\DeclareMathOperator{\im}{Im}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\Lin}{Lin}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\Char}{char}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\inner}[2]{( #1 \, | \, #2)}
\newcommand{\norm}[1]{\left\lVert #1 \right\rVert}
\newcommand{\modulus}[1]{\left| #1 \right|}
\newcommand{\abs}{\modulus}
\newtheorem{theorem}{Twierdzenie}
\newtheorem{lemat}{Lemat}
\newcommand{\ol}{\overline}
\DeclareMathOperator{\tr}{tr}
\DeclareMathOperator{\diag}{diag}
\newcommand{\+}{\enspace}
\newcommand{\sump}{\sideset{}{'}{∑}} % sum prime
\newcommand{\sumb}{\sideset{}{"}{∑}} % sum bis

\newunicodechar{∅}{\emptyset} % Digr /0
\newunicodechar{∞}{\infty} % Digr 00
\newunicodechar{∂}{\partial} % Digr dP
\newunicodechar{α}{\alpha}
\newunicodechar{β}{\beta}
\newunicodechar{ξ}{\xi} % Digr c*
\newunicodechar{δ}{\delta} % Digr d*
\newunicodechar{ε}{\varepsilon}
\newunicodechar{φ}{\varphi}
\newunicodechar{θ}{\theta} % Digr h*
\newunicodechar{λ}{\lambda}
\newunicodechar{μ}{\mu}
\newunicodechar{π}{\pi}
\newunicodechar{σ}{\sigma}
\newunicodechar{τ}{\tau}
\newunicodechar{ω}{\omega}
\newunicodechar{η}{\eta} % Digr y*
\newunicodechar{Δ}{\Delta}
\newunicodechar{Θ}{\Theta}
\newunicodechar{Φ}{\Phi} % Digr F*
\newunicodechar{Π}{\Pi}
\newunicodechar{Ψ}{\Psi} % digr Q*
\newunicodechar{ℕ}{\N} % Digr NN 8469 nonstandard
\newunicodechar{ℤ}{\Z} % Digr ZZ 8484 nonstandard
\newunicodechar{ℚ}{\Q} % Digr QQ 8474 nonstandard
\newunicodechar{ℝ}{\R} % Digr RR 8477 nonstandard
\newunicodechar{ℂ}{\C} % Digr CC 8450 nonstandard
\newunicodechar{∑}{\sum}
\newunicodechar{∏}{\prod}
\newunicodechar{∫}{\int}
\newunicodechar{∓}{\mp}
\newunicodechar{⌈}{\lceil} % Digr <7
\newunicodechar{⌉}{\rceil} % Digr >7
\newunicodechar{⌊}{\lfloor} % Digr 7<
\newunicodechar{⌋}{\rfloor} % Digr 7>
\newunicodechar{≅}{\cong} % Digr ?=
\newunicodechar{≡}{\equiv} % Digr 3=
\newunicodechar{◁}{\triangleleft} % Digr Tl
\newunicodechar{▷}{\triangleright} % Digr Tr
\newunicodechar{≤}{\le}
\newunicodechar{≥}{\ge}
\newunicodechar{≪}{\ll} % Digr <*
\newunicodechar{≫}{\gg} % Digr *>
\newunicodechar{≠}{\ne}
\newunicodechar{⊆}{\subseteq} % Digr (_
\newunicodechar{⊇}{\supseteq} % Digr _)
\newunicodechar{⊂}{\subset} % Digr (C
\newunicodechar{⊃}{\supset} % Digr C)
\newunicodechar{∩}{\cap} % Digr (U
\newunicodechar{∪}{\cup} % Digr )U
\newunicodechar{∼}{\sim} % Digr ?1
\newunicodechar{≈}{\approx} % Digr ?2
\newunicodechar{∈}{\in} % Digr (-
\newunicodechar{∋}{\ni} % Digr -)
\newunicodechar{∇}{\nabla} % Digr NB
\newunicodechar{∃}{\exists} % Digr TE
\newunicodechar{∀}{\forall} % Digr FA
\newunicodechar{∧}{\wedge} % Digr AN
\newunicodechar{∨}{\vee} % Digr OR
\newunicodechar{⊥}{\bot} % Digr -T
\newunicodechar{⊤}{\top} % Digr TO 8868 nonstandard
\newunicodechar{⇒}{\implies} % Digr =>
\newunicodechar{⇐}{\impliedby} % Digr <=
\newunicodechar{⇔}{\iff} % Digr ==
\newunicodechar{↔}{\leftrightarrow} % Digr <>
\newunicodechar{↦}{\mapsto} % Digr T> 8614 nonstandard
\newunicodechar{∘}{\circ} % Digr Ob

% cursed
\WarningFilter{newunicodechar}{Redefining Unicode}
\newunicodechar{·}{\ifmmode\cdot\else\textperiodcentered\fi} % Digr .M
\newunicodechar{×}{\ifmmode\times\else\texttimes\fi} % Digr *X
\newunicodechar{→}{\ifmmode\rightarrow\else\textrightarrow\fi} % Digr ->
\newunicodechar{←}{\ifmmode\leftarrow\else\textleftarrow\fi} % Digr ->
\newunicodechar{⟨}{\ifmmode\langle\else\textlangle\fi} % Digr LA 10216 nonstandard
\newunicodechar{⟩}{\ifmmode\rangle\else\textrangle\fi} % Digr RA 10217 nonstandard
\newunicodechar{…}{\ifmmode\dots\else\textellipsis\fi} % Digr .,
\newunicodechar{±}{\ifmmode\pm\else\textpm\fi} % Digr +-

% https://tex.stackexchange.com/a/438184
% https://tex.stackexchange.com/q/528480
\newunicodechar{∶}{\mathbin{\text{:}}}
\def\newcolon{%
  \nobreak\mskip2mu\mathpunct{}\nonscript\mkern-\thinmuskip{\text{:}}%
  \mskip 6mu plus 1 mu \relax}
\mathcode`:="8000
{\catcode`:=\active \global\let:\newcolon}
% colon: for types; ratio∶ (digr :R) for relations (set builder)


\begin{document}

\maketitle

\section*{0/4}

\begin{algorithm}
	\begin{algorithmic}
		\Procedure{Mult}{$a$, $b$}
			\State \textit{sum} $←$ 0
			\While {$a > 0$}
				\If {$a \bmod 2 = 1$}
					\State \textit{sum} $←$ \textit{sum} $+$ \textit{b}
				\EndIf
				\State $a ← a \div 2$
				\State $b ← 2*b$
			\EndWhile
			\State \Return \textit{sum}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Wartość obliczaną przez algorytm mnożenia rosyjskich chłopów dla liczb
$a$ i $b$
możemy zapisać
$$f(a,b) =
\begin{cases}
	0 & \text{ jeśli }a = 0 \\
	(a \bmod 2)b + f(\lfloor\frac{a}{2}\rfloor, 2b) & \text{ jeśli }a ≠ 0
\end{cases}
$$
Tezę $f(a,b) = ab$ możemy udowodnić poprzez indukcję względem $a$.
Przypadek bazowy $f(0,b) = 0 = 0b$ jest oczywiście prawdziwy.
Jeśli teza jest prawdziwa dla lewych argumentów mniejszych od $a>0$,
to w szczególności zachodzi równość $f(\lfloor\frac{a}{2}\rfloor, 2b) = \lfloor\frac{a}{2}\rfloor 2b.$
Zauważmy, że wtedy
\begin{align*}
ab
&= \left(\frac{a}{2}\right)2b
= \left(\left\lfloor\frac{a}{2}\right\rfloor + \left\{\frac{a}{2}\right\}\right)2b
= \left\lfloor\frac{a}{2}\right\rfloor2b + \left\{\frac{a}{2}\right\}2b \\
&= f\left(\left\lfloor\frac{a}{2}\right\rfloor,2b\right) + \left(\frac{a \bmod 2}{2}\right)2b
= f\left(\left\lfloor\frac{a}{2}\right\rfloor,2b\right) + (a \bmod 2)b,
\end{align*}
co kończy dowód.

Przy jednorodnym kryterium kosztów, zakładamy, że operacje arytmetyczne i
bitowe zajmują czas $O(1)$ i w każdej z
$\log_2 a$ iteracji wykonujemy ich dwie lub trzy, więc złożoność czasowa to
$O(\log_2 a)$.
W pamięci przechowujemy tylko dwie liczby, więc złożoność pamięciowa to $O(1)$.

Zauważmy, że w każdej iteracji liczba bitów $a$ i liczba bitów $b$
sumują się do $\log_2 ab$, więc przy logarytmicznym kryterium kosztów
algorytm ma złożoność pamięciową $Θ(\log_2 ab)$.

% to jest źle, w naszym modelu maszyny ram nie ma operacji bitowych

W każdej iteracji wykonujemy operacje przesunięcia bitowego na $a$ i $b$,
więc sumaryczny koszt tych operacji to zawsze $Θ(\log_2 ab)$.
Wewnątrz instrukcji warunkowej możemy jeszcze dodawać liczbę $b$.
Ta liczba jest zawsze przesunięciem bitowym w lewo początkowej wartości $b$,
więc koszt jej dodania to $Θ(\log_2 b)$.
Jeśli to dodawanie jest wykonywane w każdej iteracji, to kosztuje ono
$O(\log_2 a \log_2 b)$, zatem przy logarytmicznym kryterium kosztów
otrzymujemy złożoność czasową $O(\log_2 ab)$.

\section*{0/8}
Obliczenia możemy wykonywać w pierścieniu $ℤ[x]/(x^3, m)$.
$$ ((ax^2 + bx + c) - 2)^2 = (2(c-2)a+b^2)x^2 + 2(c-2)bx + (c-2)^2$$

Problem możemy sprowadzić do obliczenia $n$-tej iteracji funkcji
$$Φ\begin{pmatrix}a \\ b \\ c\end{pmatrix}
= \begin{pmatrix}2(c-2)a + b^2 \\ 2(c-2)b \\ (c-2)^2\end{pmatrix}
$$
na argumencie $x_0 = \begin{psmallmatrix}0 \\ 1 \\ 0\end{psmallmatrix}$
(odpowiadającym wielomianowi $x$).

Zauważmy, że trzecia współrzędna $Φ^n(x_0)$ dla $n>0$ będzie zawsze równa $4$,
a co za tym idzie, druga współrzędna będzie czterokrotnością drugiej
współrzędnej argumentu.
Druga współrzędna $Φ(x_0)$ to $-4$, więc druga współrzędna $Φ^n(x_0)$ to $-4^n$.
Zatem problem się upraszcza do obliczenia $a_n = φ^n(0)$, gdzie
$$φ(a)
= 4a + ((-4)^n)^2 = 4a + 16^n.
$$

Obliczanie tych iteracji możemy zapisać w postaci macierzowej jako
$$
\begin{pmatrix}
	a_n \\
	16^n
\end{pmatrix}
=
\begin{pmatrix}
	4 & 1 \\
	0 & 16
\end{pmatrix}^n
\begin{pmatrix}
	a_0 \\
	16^0
\end{pmatrix}
=
\begin{pmatrix}
	4 & 1 \\
	0 & 16
\end{pmatrix}^n
\begin{pmatrix}
	0 \\
	1
\end{pmatrix},
$$
czyli wystarczy obliczyć lewy górny róg $n$-tej potęgi macierzy.


\newpage
\section*{1/1}


\begin{verbatim}
data Tree = Leaf | Branch Tree Tree

nodeCount Leaf         = 1
nodeCount (Branch l r) = 1 + nodeCount l + nodeCount r

-- liczy średnicę i wysokość drzewa
go Leaf         = (0, 0)
go (Branch l r) =
  let ((ld, lh), (rd, rh)) = (go l, go r) in
  (maximum [lh + rh + 2, ld, rd], maximum [lh, rh] + 1)

diameter t = fst (go t)

\end{verbatim}


\section*{1/3}
Do problemu wystarczy użyć algorytmu Kahna zmodyfikowanego tak, by
używał kolejki priorytetowej.

\begin{algorithm}
	\begin{algorithmic}
		\State $L$ $←$ $[]$
		\State $Q$ $←$ kolejka priorytetowa wierzchołków bez krawędzi wchodzących
		\While{$Q$ \textbf{is not empty}}
			\State $v$ $←$ \textit{pop-min}($Q$)
			\State \textit{push}($L$, $v$)
			\For{$e=(v,u)$ \textbf{in} \textit{outcoming-edges}($v$)}
				\State \textit{remove-from-graph}($e$)
				\If{\textit{incoming-edges}($u$) \textbf{is empty}}
					\State \textit{insert}($Q$, $u$)
				\EndIf
			\EndFor
		\EndWhile
		\State \Return $L$
	\end{algorithmic}
\end{algorithm}


\end{document}
