\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{silence}
\usepackage{polski}
\usepackage{parskip}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{enumitem}
%\usepackage{pgfplots}
%\pgfplotsset{compat=1.16}
\usepackage{newunicodechar}
\usepackage{etoolbox}
\usepackage[margin=1.2in]{geometry}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\setcounter{secnumdepth}{0}

\title{}
\author{Wiktor Kuchta}
\date{\vspace{-4ex}}

\DeclareMathOperator{\im}{Im}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\Lin}{Lin}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\Char}{char}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\inner}[2]{( #1 \, | \, #2)}
\newcommand{\norm}[1]{\left\lVert #1 \right\rVert}
\newcommand{\modulus}[1]{\left| #1 \right|}
\newcommand{\abs}{\modulus}
\newtheorem{theorem}{Twierdzenie}
\newtheorem{lemat}{Lemat}
\newcommand{\ol}{\overline}
\DeclareMathOperator{\tr}{tr}
\DeclareMathOperator{\diag}{diag}
\newcommand{\+}{\enspace}
\newcommand{\sump}{\sideset{}{'}{∑}} % sum prime
\newcommand{\sumb}{\sideset{}{"}{∑}} % sum bis

\newunicodechar{∅}{\emptyset} % Digr /0
\newunicodechar{∞}{\infty} % Digr 00
\newunicodechar{∂}{\partial} % Digr dP
\newunicodechar{α}{\alpha}
\newunicodechar{β}{\beta}
\newunicodechar{ξ}{\xi} % Digr c*
\newunicodechar{δ}{\delta} % Digr d*
\newunicodechar{ε}{\varepsilon}
\newunicodechar{φ}{\varphi}
\newunicodechar{θ}{\theta} % Digr h*
\newunicodechar{λ}{\lambda}
\newunicodechar{μ}{\mu}
\newunicodechar{π}{\pi}
\newunicodechar{σ}{\sigma}
\newunicodechar{τ}{\tau}
\newunicodechar{ω}{\omega}
\newunicodechar{η}{\eta} % Digr y*
\newunicodechar{Δ}{\Delta}
\newunicodechar{Θ}{\Theta}
\newunicodechar{Φ}{\Phi} % Digr F*
\newunicodechar{Π}{\Pi}
\newunicodechar{Ψ}{\Psi} % digr Q*
\newunicodechar{ℕ}{\N} % Digr NN 8469 nonstandard
\newunicodechar{ℤ}{\Z} % Digr ZZ 8484 nonstandard
\newunicodechar{ℚ}{\Q} % Digr QQ 8474 nonstandard
\newunicodechar{ℝ}{\R} % Digr RR 8477 nonstandard
\newunicodechar{ℂ}{\C} % Digr CC 8450 nonstandard
\newunicodechar{∑}{\sum}
\newunicodechar{∏}{\prod}
\newunicodechar{∫}{\int}
\newunicodechar{∓}{\mp}
\newunicodechar{⌈}{\lceil} % Digr <7
\newunicodechar{⌉}{\rceil} % Digr >7
\newunicodechar{⌊}{\lfloor} % Digr 7<
\newunicodechar{⌋}{\rfloor} % Digr 7>
\newunicodechar{≅}{\cong} % Digr ?=
\newunicodechar{≡}{\equiv} % Digr 3=
\newunicodechar{◁}{\triangleleft} % Digr Tl
\newunicodechar{▷}{\triangleright} % Digr Tr
\newunicodechar{≤}{\le}
\newunicodechar{≥}{\ge}
\newunicodechar{≪}{\ll} % Digr <*
\newunicodechar{≫}{\gg} % Digr *>
\newunicodechar{≠}{\ne}
\newunicodechar{⊆}{\subseteq} % Digr (_
\newunicodechar{⊇}{\supseteq} % Digr _)
\newunicodechar{⊂}{\subset} % Digr (C
\newunicodechar{⊃}{\supset} % Digr C)
\newunicodechar{∩}{\cap} % Digr (U
\newunicodechar{∪}{\cup} % Digr )U
\newunicodechar{∼}{\sim} % Digr ?1
\newunicodechar{≈}{\approx} % Digr ?2
\newunicodechar{∈}{\in} % Digr (-
\newunicodechar{∋}{\ni} % Digr -)
\newunicodechar{∇}{\nabla} % Digr NB
\newunicodechar{∃}{\exists} % Digr TE
\newunicodechar{∀}{\forall} % Digr FA
\newunicodechar{∧}{\wedge} % Digr AN
\newunicodechar{∨}{\vee} % Digr OR
\newunicodechar{⊥}{\bot} % Digr -T
\newunicodechar{⊤}{\top} % Digr TO 8868 nonstandard
\newunicodechar{⇒}{\implies} % Digr =>
\newunicodechar{⇐}{\impliedby} % Digr <=
\newunicodechar{⇔}{\iff} % Digr ==
\newunicodechar{↔}{\leftrightarrow} % Digr <>
\newunicodechar{↦}{\mapsto} % Digr T> 8614 nonstandard
\newunicodechar{∘}{\circ} % Digr Ob

% cursed
\WarningFilter{newunicodechar}{Redefining Unicode}
\newunicodechar{·}{\ifmmode\cdot\else\textperiodcentered\fi} % Digr .M
\newunicodechar{×}{\ifmmode\times\else\texttimes\fi} % Digr *X
\newunicodechar{→}{\ifmmode\rightarrow\else\textrightarrow\fi} % Digr ->
\newunicodechar{←}{\ifmmode\leftarrow\else\textleftarrow\fi} % Digr ->
\newunicodechar{⟨}{\ifmmode\langle\else\textlangle\fi} % Digr LA 10216 nonstandard
\newunicodechar{⟩}{\ifmmode\rangle\else\textrangle\fi} % Digr RA 10217 nonstandard
\newunicodechar{…}{\ifmmode\dots\else\textellipsis\fi} % Digr .,
\newunicodechar{±}{\ifmmode\pm\else\textpm\fi} % Digr +-

% https://tex.stackexchange.com/a/438184
% https://tex.stackexchange.com/q/528480
\newunicodechar{∶}{\mathbin{\text{:}}}
\def\newcolon{%
  \nobreak\mskip2mu\mathpunct{}\nonscript\mkern-\thinmuskip{\text{:}}%
  \mskip 6mu plus 1 mu \relax}
\mathcode`:="8000
{\catcode`:=\active \global\let:\newcolon}
% colon: for types; ratio∶ (digr :R) for relations (set builder)


\begin{document}

\maketitle
\section*{3/1}
\begin{algorithm}
	\begin{algorithmic}
		\Procedure{Gcd}{$a$, $b$}
			\Procedure{Iter}{$a$, $b$, $m$}
			\If{$a > b$}
				\State \Return \textsc{Iter}($b$, $a$, $m$)
			\ElsIf{$a = 0$}% \textbf{or} $|a| = |b|$}
				\State \Return $mb$
			\ElsIf{even $a$ \textbf{and} even $b$}
				\State \Return \textsc{Iter}($a/2$, $b/2$, $2m$)
			\ElsIf{even $a$ \textbf{and} odd $b$}
				\State \Return \textsc{Iter}($a/2$, $b$, $m$)
			\ElsIf{odd $a$ \textbf{and} even $b$}
				\State \Return \textsc{Iter}($a$, $b/2$, $m$)
			\ElsIf{odd $a$ \textbf{and} odd $b$}
				\State \Return \textsc{Iter}($a$, $(b-a)/2$, $m$)
			\EndIf
			\EndProcedure
			\State \Return \textsc{Iter}($a$, $b$, $1$)
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
W każdym wywołaniu (poza zamianą argumentów), jeden z argumentów
jest co najmniej dwa razy mniejszy niż wcześniej.
Zatem algorytm wykonuje $O(\lg a + \lg b)$ wykonań rekurencyjnych.

Przy jednorodnym kryterium kosztów operacje w każdym wywołaniu zajmują
$O(1)$ czasu, a przy logarytmicznym $O(\lg a + \lg b)$.

Zakładając optymalizację wywołań ogonowych,
przy jednorodnym kryterium kosztów algorytm potrzebuje $O(1)$ pamięci,
a przy logarytmicznym $O(\lg a + \lg b)$.
Trzymanie akumulatora $m$ nie zwiększa zużycia pamięci, bo początkowo
zajmuje $1$ bit, a zwiększamy liczbę zajmowanych bitów o $1$ kiedy zmniejszamy
liczbę bitów zajmowanych przez $a$ i $b$ o $1$.

Algorytm Euklidesa ma takie samy koszty każdej iteracji i potrzebuje tyle samo pamięci,
ale wykonuje tylko $O(\lg\min\{a, b\})$ iteracji.

\section*{3/2}
Liczba porównań algorytmu \textit{MaxMin} dla zbioru $n$-elementowego jest równa
$$c(n) =
\begin{cases}
	0 & n < 2 \\
	1 & n = 2 \\
	c\left(\lfloor \frac{n}{2} \rfloor\right) + c\left(\lceil \frac{n}{2} \rceil\right) + 2 & n > 2
\end{cases}.$$

Pokażemy indukcyjnie, że
$$\left\lceil \tfrac{3}{2}n\right\rceil-2 = c(n) ⇔ ∃k.\, n ∈ \{ 2^k-1, 2^k, 2^k+1 \}.$$
Można sprawdzić, że to prawda dla $n≤5$.
Załóżmy, że to prawda dla liczb mniejszych od $n$.

\begin{enumerate}
	\item Jeśli $n=2^k+σ$, gdzie $σ∈\{-1,0,1\}$, to $c(n) = c(2^{k-1})+c(2^{k-1}+σ)+2.$
		Z założenia indukcyjnego jest to równe
		$\left\lceil \tfrac{3}{2}2^{k-1} \right\rceil
		+\left\lceil \tfrac{3}{2}(2^{k-1}+σ) \right\rceil - 2
		=\left\lceil \tfrac{3}{2}(2^{k}+σ) \right\rceil - 2$.
	\item Jeśli $n=2^k±2$, to $c(n) = 2c(2^{k-1}±1)+2 =
		2\left\lceil \tfrac{3}{2}(2^{k-1}±1) \right\rceil-2 =
		\left\lceil \tfrac{3}{2}2^{k} \right\rceil + 2\left\lceil ±\tfrac{3}{2}\right\rceil-2
		=\left\lceil \tfrac{3}{2}(2^{k}±2) \right\rceil -1.$
	\item Jeśli $n$ nie jest żadnym z powyższych, to jedno z
		$c\left(\lfloor \tfrac{n}{2} \rfloor\right)
		,c\left(\lceil \tfrac{n}{2} \rceil\right)$ jest nieoptymalne, tzn.
		$c(n) >
		\left\lceil\tfrac{3}{2}\lfloor \tfrac{n}{2} \rfloor - 2\right\rceil
		+\left\lceil\tfrac{3}{2}\lceil \tfrac{n}{2} \rceil - 2\right\rceil + 2
		≥ \left\lceil \tfrac{3}{2}n - 2 \right\rceil$.
\end{enumerate}

Różnica $c(n)$ i $\left\lceil \tfrac{3}{2}n\right\rceil$ jest nieograniczona.

Dla $n$ parzystych, możemy podzielić zbiór na pary i porównać każdą parę,
otrzymując po $n/2$ potencjalnych minimów i maksimów.
W tych grupach znajdujemy w $n/2-1$ porównań odpowiednio minimum i maksimum.
W sumie skorzystaliśmy z $n/2 + 2(n/2-1) = 3n/2 - 2$ porównań.
Jeśli mamy dodatkowo jeszcze jeden element, to musimy wykonać jeszcze dwa porównania,
więc ogólnie ten algorytm wykonuje $\lceil \tfrac{3n}{2} \rceil - 2$ porównań.

\section*{3/3}
Mamy dwie otoczki wypukłe rozdzielone pionową kreską.
Musimy znaleźć górną i dolną prostą styczną do obu otoczek.
Takie proste styczne przechodzą przez wierzchołki otoczek, więc
będziemy rozpatrywać odcinek łączący wierzchołki obu otoczek i
zmieniać końce tego przecinka, aż odcinek będzie leżał na odpowiedniej prostej.

Zajmiemy się górną styczną, dla dolnej jest symetrycznie.
Zaczniemy z odcinkiem przechodzącym przez punkt najbardziej na prawo lewej otoczki
i punkt najbardziej na lewo prawej otoczki.
Aby sprawdzić, czy prosta, na której leży ten odcinek, przecina prawą figurę
i powinniśmy jej prawy koniec przesunąć do wierzchołka wyżej, wystarczy
sprawdzić czy te wierzchołki (obecny i potencjalny nowy koniec) prawej figury
leżą po odpowiedniej stronie prostej.
Symetrycznie dla lewej figury.

Zatem będziemy przesuwać końce odcinka do góry, aż ta prosta nie będzie przecinać
żadnej z figur.
Wykonamy takich porównań i przesunięć co najwyżej tyle, ile jest wierzchołków
na otoczkach.






\end{document}
